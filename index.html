<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Project Board</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            min-height: 100vh;
        }

        .header {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header h1 {
            color: #f0f6fc;
            font-size: 1.5rem;
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        input, select, button {
            background: #21262d;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #1f6feb;
            box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.1);
        }

        button {
            cursor: pointer;
            background: #238636;
            border-color: #238636;
            font-weight: 500;
        }

        button:hover {
            background: #2ea043;
        }

        button:disabled {
            background: #30363d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .template-btn {
            background: #1f6feb !important;
            border-color: #1f6feb !important;
        }

        .template-btn:hover {
            background: #388bfd !important;
        }

        .secondary-btn {
            background: #f85149 !important;
            border-color: #f85149 !important;
        }

        .secondary-btn:hover {
            background: #ff7066 !important;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .connected { background: #238636; }
        .disconnected { background: #f85149; }
        .syncing { background: #d29922; }

        .connection-banner {
            background: #238636;
            color: white;
            padding: 0.75rem 2rem;
            display: none;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2ea043;
            font-weight: 500;
        }

        .connection-banner.show {
            display: flex;
        }

        .connection-banner.error {
            background: #f85149;
        }

        .connection-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .connection-details {
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .repo-name {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
        }

        .connection-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .sync-status {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .controls {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .board {
            display: flex;
            gap: 2rem;
            padding: 2rem;
            overflow-x: auto;
            min-height: calc(100vh - 200px);
        }

        .column {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            min-width: 300px;
            max-width: 300px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #30363d;
        }

        .column-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .item-count {
            background: #30363d;
            color: #8b949e;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .column-items {
            flex: 1;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .item {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 1rem;
            cursor: grab;
            transition: all 0.2s;
        }

        .item:hover {
            border-color: #1f6feb;
            transform: translateY(-1px);
        }

        .item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .item.github-synced::before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #238636;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
        }

        .item-title {
            font-weight: 600;
            font-size: 0.875rem;
            line-height: 1.4;
            flex: 1;
            margin-right: 0.5rem;
        }

        .item-number {
            color: #8b949e;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .item-body {
            color: #8b949e;
            font-size: 0.75rem;
            line-height: 1.4;
            margin-bottom: 0.75rem;
        }

        .item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: #8b949e;
        }

        .item-labels {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .label {
            background: #1f6feb;
            color: white;
            padding: 0.125rem 0.375rem;
            border-radius: 12px;
            font-size: 0.625rem;
            font-weight: 500;
        }

        .column.drag-over {
            background: rgba(31, 111, 235, 0.1);
            border-color: #1f6feb;
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 1rem;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.75rem;
            z-index: 1000;
            display: none;
        }

        .debug-panel.show {
            display: block;
        }

        .debug-log {
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            border-radius: 3px;
        }

        .debug-log.info { background: rgba(31, 111, 235, 0.1); }
        .debug-log.error { background: rgba(248, 81, 73, 0.1); }
        .debug-log.success { background: rgba(35, 134, 54, 0.1); }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
        }

        .offline-indicator {
            background: #f85149;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            margin-left: 1rem;
            font-size: 0.75rem;
        }

        .cors-help {
            background: #d29922;
            color: #0d1117;
            padding: 1rem;
            margin: 1rem 2rem;
            border-radius: 6px;
            font-weight: 500;
            display: none;
        }

        .cors-help.show {
            display: block;
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .controls {
                padding: 1rem;
            }
            
            .board {
                padding: 1rem;
                gap: 1rem;
            }
            
            .column {
                min-width: 280px;
                max-width: 280px;
            }
            
            .debug-panel {
                width: 250px;
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GitHub Project Board</h1>
        <div class="auth-section">
            <div class="input-group">
                <span class="status-indicator disconnected" id="connectionStatus"></span>
                <input type="password" id="tokenInput" placeholder="GitHub Personal Access Token" />
            </div>
            <div class="input-group">
                <input type="text" id="repoInput" placeholder="username/repository" />
                <select id="repoSelect" style="display: none;">
                    <option value="">Select Repository...</option>
                </select>
            </div>
            <button id="connectBtn">Connect</button>
            <button id="syncBtn" disabled>Sync</button>
            <button id="queueBtn" class="secondary-btn" style="display: none;">Queue (<span id="queueCount">0</span>)</button>
            <button class="secondary-btn" id="debugToggle">Debug</button>
        </div>
    </div>

    <div class="connection-banner" id="connectionBanner">
        <div class="connection-info">
            <div class="connection-details">
                <span>✅ Connected to</span>
                <span class="repo-name" id="connectedRepo"></span>
                <span>as</span>
                <span id="connectedUser"></span>
            </div>
        </div>
        <div class="connection-actions">
            <span class="sync-status" id="syncStatus">Last synced: Never</span>
            <button id="disconnectBtn" class="secondary-btn" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">Disconnect</button>
        </div>
    </div>

    <div class="cors-help" id="corsHelp">
        ⚠️ CORS Error Detected: You must run this from a web server. 
        Save this file as 'index.html' then run: <code>python3 -m http.server 8000</code> 
        and open: <code>http://localhost:8000/index.html</code>
    </div>

    <div class="controls">
        <div class="input-group">
            <button id="addItemBtn">Add Item</button>
            <button id="bulkImportBtn">Bulk Import</button>
            <button id="templateBtn" class="template-btn">📋 Template</button>
            <button id="exportBtn">Export</button>
        </div>
        <div class="input-group">
            <input type="text" id="searchInput" placeholder="Search items..." />
            <select id="filterSelect">
                <option value="">All Items</option>
                <option value="github">GitHub Synced</option>
                <option value="local">Local Only</option>
            </select>
        </div>
        <div id="offlineIndicator" class="offline-indicator" style="display: none;">
            Offline Mode
        </div>
    </div>

    <div class="board" id="board">
        <div class="column" data-status="backlog">
            <div class="column-header">
                <span class="column-title">Backlog</span>
                <span class="item-count" id="backlog-count">0</span>
            </div>
            <div class="column-items" id="backlog-items"></div>
        </div>

        <div class="column" data-status="todo">
            <div class="column-header">
                <span class="column-title">To Do</span>
                <span class="item-count" id="todo-count">0</span>
            </div>
            <div class="column-items" id="todo-items"></div>
        </div>

        <div class="column" data-status="in-progress">
            <div class="column-header">
                <span class="column-title">In Progress</span>
                <span class="item-count" id="in-progress-count">0</span>
            </div>
            <div class="column-items" id="in-progress-items"></div>
        </div>

        <div class="column" data-status="review">
            <div class="column-header">
                <span class="column-title">Review</span>
                <span class="item-count" id="review-count">0</span>
            </div>
            <div class="column-items" id="review-items"></div>
        </div>

        <div class="column" data-status="done">
            <div class="column-header">
                <span class="column-title">Done</span>
                <span class="item-count" id="done-count">0</span>
            </div>
            <div class="column-items" id="done-items"></div>
        </div>
    </div>

    <div class="debug-panel" id="debugPanel">
        <div id="debugLogs"></div>
    </div>

    <div class="modal" id="itemModal">
        <div class="modal-content">
            <div class="modal-header">Add/Edit Item</div>
            <form id="itemForm">
                <div class="form-group">
                    <label for="itemTitle">Title *</label>
                    <input type="text" id="itemTitle" required />
                </div>
                <div class="form-group">
                    <label for="itemBody">Description</label>
                    <textarea id="itemBody" placeholder="Markdown supported..."></textarea>
                </div>
                <div class="form-group">
                    <label for="itemStatus">Status</label>
                    <select id="itemStatus">
                        <option value="backlog">Backlog</option>
                        <option value="todo">To Do</option>
                        <option value="in-progress">In Progress</option>
                        <option value="review">Review</option>
                        <option value="done">Done</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="itemLabels">Labels (comma-separated)</label>
                    <input type="text" id="itemLabels" placeholder="bug, feature, enhancement" />
                </div>
                <div class="form-group">
                    <label for="itemAssignee">Assignee</label>
                    <input type="text" id="itemAssignee" placeholder="GitHub username" />
                </div>
                <div class="form-actions">
                    <button type="button" class="secondary-btn" id="cancelBtn">Cancel</button>
                    <button type="submit">Save</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        class GitHubProjectBoard {
            constructor() {
                this.token = localStorage.getItem('github_token') || '';
                this.repo = localStorage.getItem('github_repo') || '';
                this.connectedUser = localStorage.getItem('github_user') || '';
                this.items = JSON.parse(localStorage.getItem('board_items') || '[]');
                this.isOnline = navigator.onLine;
                this.syncQueue = JSON.parse(localStorage.getItem('sync_queue') || '[]');
                this.debugMode = false;
                this.repoData = null;
                this.syncTimeout = null;
                this.isProcessingQueue = false;
                
                this.statusMapping = {
                    'backlog': 'open',
                    'todo': 'open',
                    'in-progress': 'open',
                    'review': 'open',
                    'done': 'closed'
                };

                this.reverseStatusMapping = {
                    'open': 'todo',
                    'closed': 'done'
                };

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.renderBoard();
                this.updateConnectionStatus();
                this.updateQueueDisplay();
                this.setupDragAndDrop();
                this.loadInitialData();
                this.startPeriodicSync();
                
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.hideOfflineIndicator();
                    this.log('Connection restored - processing sync queue', 'info');
                    this.processSyncQueue();
                });
                
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.showOfflineIndicator();
                    this.log('Connection lost - operations will be queued', 'info');
                });
            }

            log(message, type = 'info') {
                console.log(`[${type.toUpperCase()}] ${message}`);
                
                if (this.debugMode) {
                    const debugLogs = document.getElementById('debugLogs');
                    const logEntry = document.createElement('div');
                    logEntry.className = `debug-log ${type}`;
                    logEntry.innerHTML = `${new Date().toLocaleTimeString()}: ${message}`;
                    debugLogs.insertBefore(logEntry, debugLogs.firstChild);
                    
                    if (debugLogs.children.length > 50) {
                        debugLogs.removeChild(debugLogs.lastChild);
                    }
                }
            }

            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('syncBtn').addEventListener('click', () => this.syncWithGitHub());
                document.getElementById('queueBtn').addEventListener('click', () => this.showSyncQueue());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('debugToggle').addEventListener('click', () => this.toggleDebug());
                
                document.getElementById('repoSelect').addEventListener('change', (e) => {
                    if (e.target.value) {
                        document.getElementById('repoInput').value = e.target.value;
                    }
                });
                
                document.getElementById('addItemBtn').addEventListener('click', () => this.showItemModal());
                document.getElementById('bulkImportBtn').addEventListener('click', () => this.bulkImport());
                document.getElementById('templateBtn').addEventListener('click', () => this.downloadTemplate());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                
                document.getElementById('searchInput').addEventListener('input', (e) => this.searchItems(e.target.value));
                document.getElementById('filterSelect').addEventListener('change', (e) => this.filterItems(e.target.value));
                
                document.getElementById('cancelBtn').addEventListener('click', () => this.hideItemModal());
                document.getElementById('itemForm').addEventListener('submit', (e) => this.handleItemSubmit(e));
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.hideItemModal();
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        this.saveData();
                    }
                });
            }

            async loadUserRepositories() {
                try {
                    const response = await fetch('https://api.github.com/user/repos?sort=updated&per_page=50', {
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'GitHub-Project-Board/1.0'
                        }
                    });

                    if (response.ok) {
                        const repos = await response.json();
                        const repoSelect = document.getElementById('repoSelect');
                        
                        repoSelect.innerHTML = '<option value="">Select Repository...</option>';
                        repos.forEach(repo => {
                            const option = document.createElement('option');
                            option.value = repo.full_name;
                            option.textContent = `${repo.full_name} ${repo.private ? '🔒' : '📖'}`;
                            repoSelect.appendChild(option);
                        });
                        
                        repoSelect.style.display = 'inline-block';
                        this.log(`Loaded ${repos.length} repositories`, 'success');
                    }
                } catch (error) {
                    this.log(`Failed to load repositories: ${error.message}`, 'error');
                }
            }

            async connect() {
                const token = document.getElementById('tokenInput').value.trim();
                const repo = document.getElementById('repoInput').value.trim();
                
                if (!token || !repo) {
                    this.log('Token and repository are required', 'error');
                    return;
                }
                
                if (!token.startsWith('ghp_') && !token.startsWith('github_pat_')) {
                    this.log('Invalid token format. Token should start with "ghp_" or "github_pat_"', 'error');
                    return;
                }
                
                if (!/^[^\/]+\/[^\/]+$/.test(repo)) {
                    this.log('Invalid repository format. Use: username/repository-name', 'error');
                    return;
                }
                
                this.log('Attempting GitHub connection...');
                
                try {
                    this.log('Testing API connectivity...');
                    const userResponse = await fetch('https://api.github.com/user', {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'GitHub-Project-Board/1.0'
                        }
                    });
                    
                    if (!userResponse.ok) {
                        if (userResponse.status === 401) {
                            throw new Error('Invalid token or insufficient permissions');
                        } else if (userResponse.status === 403) {
                            throw new Error('Token lacks required permissions. Ensure "repo" scope is enabled');
                        } else {
                            throw new Error(`GitHub API error: ${userResponse.status} ${userResponse.statusText}`);
                        }
                    }
                    
                    const user = await userResponse.json();
                    this.log(`Authenticated as: ${user.login}`, 'success');
                    
                    // Load user repositories for quick selection
                    await this.loadUserRepositories();
                    
                    this.log('Testing repository access...');
                    const repoResponse = await fetch(`https://api.github.com/repos/${repo}`, {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'GitHub-Project-Board/1.0'
                        }
                    });
                    
                    if (!repoResponse.ok) {
                        if (repoResponse.status === 404) {
                            throw new Error('Repository not found or no access permissions');
                        } else {
                            throw new Error(`Repository access failed: ${repoResponse.status} ${repoResponse.statusText}`);
                        }
                    }
                    
                    const repoData = await repoResponse.json();
                    this.log(`Connected to repository: ${repoData.full_name}`, 'success');
                    
                    this.token = token;
                    this.repo = repo;
                    this.connectedUser = user.login;
                    this.repoData = repoData;
                    localStorage.setItem('github_token', token);
                    localStorage.setItem('github_repo', repo);
                    localStorage.setItem('github_user', user.login);
                    
                    this.showConnectionBanner();
                    this.updateConnectionStatus(true);
                    document.getElementById('syncBtn').disabled = false;
                    document.getElementById('corsHelp').classList.remove('show');
                    this.log('Successfully connected to GitHub', 'success');
                    
                    await this.syncWithGitHub();
                    
                } catch (error) {
                    let errorMessage = error.message;
                    
                    if (error.message === 'Failed to fetch') {
                        errorMessage = 'Connection blocked - likely CORS issue. Ensure you\'re running from a web server, not file:// URL.';
                        document.getElementById('corsHelp').classList.add('show');
                        this.log('CORS SOLUTION: Save as HTML file and run: python3 -m http.server 8000', 'error');
                        this.log('Then open: http://localhost:8000/index.html', 'error');
                        this.log('Current URL should be http:// not file://', 'error');
                    } else if (error.message.includes('TypeError')) {
                        errorMessage = 'Network error - check internet connection and firewall settings';
                    }
                    
                    this.showConnectionError(errorMessage);
                    this.log(`Connection failed: ${errorMessage}`, 'error');
                    this.updateConnectionStatus(false);
                }
            }

            disconnect() {
                if (!confirm('Disconnect from GitHub? Local data will be preserved.')) return;

                this.token = '';
                this.repo = '';
                this.connectedUser = '';
                this.repoData = null;
                
                localStorage.removeItem('github_token');
                localStorage.removeItem('github_repo');
                localStorage.removeItem('github_user');
                
                this.hideConnectionBanner();
                this.updateConnectionStatus(false);
                document.getElementById('syncBtn').disabled = true;
                document.getElementById('repoSelect').style.display = 'none';
                
                // Clear input fields
                document.getElementById('tokenInput').value = '';
                document.getElementById('repoInput').value = '';
                
                this.log('Disconnected from GitHub', 'info');
            }

            showConnectionBanner() {
                const banner = document.getElementById('connectionBanner');
                const repoElement = document.getElementById('connectedRepo');
                const userElement = document.getElementById('connectedUser');
                
                repoElement.textContent = this.repo;
                userElement.textContent = `@${this.connectedUser}`;
                
                banner.classList.remove('error');
                banner.classList.add('show');
                
                this.updateSyncStatus('Connected');
            }

            showConnectionError(message) {
                const banner = document.getElementById('connectionBanner');
                const repoElement = document.getElementById('connectedRepo');
                const userElement = document.getElementById('connectedUser');
                
                repoElement.textContent = 'Connection Failed';
                userElement.textContent = message;
                
                banner.classList.add('error', 'show');
                
                // Hide error banner after 5 seconds
                setTimeout(() => {
                    banner.classList.remove('show');
                }, 5000);
            }

            hideConnectionBanner() {
                const banner = document.getElementById('connectionBanner');
                banner.classList.remove('show', 'error');
            }

            updateSyncStatus(status) {
                const syncStatus = document.getElementById('syncStatus');
                if (status === 'Connected') {
                    syncStatus.textContent = 'Ready to sync';
                } else if (status === 'Syncing') {
                    syncStatus.textContent = 'Syncing...';
                } else {
                    syncStatus.textContent = `Last synced: ${new Date().toLocaleTimeString()}`;
                }
            }

            async syncWithGitHub() {
                if (!this.token || !this.repo || !this.isOnline) {
                    this.log('Cannot sync: missing credentials or offline', 'error');
                    return;
                }

                this.log('Starting GitHub sync...');
                this.updateConnectionStatus('syncing');
                this.updateSyncStatus('Syncing');

                try {
                    await this.fetchGitHubIssues();
                    await this.processSyncQueue();
                    this.updateSyncStatus('Complete');
                    this.log('Sync completed successfully', 'success');
                } catch (error) {
                    this.log(`Sync failed: ${error.message}`, 'error');
                } finally {
                    this.updateConnectionStatus(true);
                }
            }

            async fetchGitHubIssues() {
                // Fetch only open issues - anything not here is considered deleted/closed
                const response = await fetch(`https://api.github.com/repos/${this.repo}/issues?state=open&per_page=100`, {
                    headers: {
                        'Authorization': `token ${this.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'GitHub-Project-Board/1.0'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch issues: ${response.status}`);
                }

                const issues = await response.json();
                this.log(`📝 [SOURCE-007] Fetched ${issues.length} open issues from GitHub`, 'info');

                // Track which GitHub issue IDs still exist (are open)
                const activeGitHubIds = new Set();
                
                // Process all open issues from GitHub
                for (const issue of issues) {
                    activeGitHubIds.add(issue.id);
                    const existingItem = this.items.find(item => item.githubId === issue.id);
                    
                    const itemData = {
                        id: existingItem?.id || this.generateId(),
                        githubId: issue.id,
                        githubNumber: issue.number,
                        title: issue.title,
                        body: issue.body || '',
                        status: this.reverseStatusMapping[issue.state] || 'todo',
                        labels: issue.labels.map(label => label.name),
                        assignee: issue.assignee?.login || '',
                        createdAt: issue.created_at,
                        updatedAt: issue.updated_at,
                        url: issue.html_url,
                        synced: true
                    };

                    if (existingItem) {
                        // Check if status changed during sync - this should NOT trigger comments
                        const statusChanged = existingItem.status !== itemData.status;
                        Object.assign(existingItem, itemData);
                        if (statusChanged) {
                            this.log(`📝 [SOURCE-007] Status sync from GitHub (NO COMMENT): ${existingItem.title} - status now ${itemData.status}`, 'info');
                        } else {
                            this.log(`📝 [SOURCE-007] Updated item from GitHub: ${issue.title}`, 'info');
                        }
                    } else {
                        this.items.push(itemData);
                        this.log(`📝 [SOURCE-007] Added new item from GitHub: ${issue.title}`, 'info');
                    }
                }

                // Remove any synced items that no longer exist in GitHub (deleted or closed)
                const itemsBeforeCleanup = this.items.length;
                this.items = this.items.filter(item => {
                    // Keep local-only items (not synced yet)
                    if (!item.synced || !item.githubId) {
                        return true;
                    }
                    
                    // Keep items that still exist in GitHub as open issues
                    if (activeGitHubIds.has(item.githubId)) {
                        return true;
                    }
                    
                    // Remove items that no longer exist in GitHub
                    this.log(`📝 [SOURCE-007] Removing item no longer in GitHub: ${item.title}`, 'info');
                    return false;
                });
                
                const removedCount = itemsBeforeCleanup - this.items.length;
                if (removedCount > 0) {
                    this.log(`📝 [SOURCE-007] Removed ${removedCount} items that were deleted/closed in GitHub`, 'success');
                }

                this.saveData();
                this.renderBoard();
            }

            async processSyncQueue() {
                if (!this.isOnline || this.syncQueue.length === 0) return;
                
                if (this.isProcessingQueue) {
                    this.log('⏳ Sync queue already being processed, skipping...', 'info');
                    return;
                }
                
                this.isProcessingQueue = true;
                this.log(`Processing ${this.syncQueue.length} queued operations`);

                for (const operation of [...this.syncQueue]) {
                    try {
                        this.log(`Processing ${operation.type} operation for: ${operation.data.title}`, 'info');
                        await this.processSyncOperation(operation);
                        this.syncQueue = this.syncQueue.filter(op => op.id !== operation.id);
                    } catch (error) {
                        this.log(`Failed to process ${operation.type} operation: ${error.message}`, 'error');
                    }
                }

                localStorage.setItem('sync_queue', JSON.stringify(this.syncQueue));
                this.updateQueueDisplay();
                this.log(`Sync queue processed. ${this.syncQueue.length} operations remaining`, 'info');
                
                this.isProcessingQueue = false;
            }

            async processSyncOperation(operation) {
                this.log(`🔄 [SOURCE-005] Processing ${operation.type} operation for: ${operation.data.title}`, 'info');
                
                switch (operation.type) {
                    case 'create':
                        await this.createGitHubIssue(operation.data);
                        break;
                    case 'update':
                        await this.updateGitHubIssue(operation.data);
                        break;
                    case 'close':
                        this.log(`🗑️ [SOURCE-005] Processing close operation for GitHub issue #${operation.data.githubNumber}`, 'info');
                        await this.closeGitHubIssue(operation.data);
                        break;
                    case 'comment':
                        const sourceInfo = operation.data.sourceLocation ? ` [${operation.data.sourceLocation}]` : '';
                        this.log(`💬 [SOURCE-005] Adding comment to GitHub issue #${operation.data.githubNumber}${sourceInfo}`, 'info');
                        await this.addCommentToIssue(operation.data.githubNumber, operation.data.commentBody);
                        this.log(`✅ [SOURCE-005] Comment added to issue #${operation.data.githubNumber}${sourceInfo}`, 'success');
                        break;
                    default:
                        this.log(`[SOURCE-005] Unknown operation type: ${operation.type}`, 'error');
                }
            }

            async createGitHubIssue(item) {
                const response = await fetch(`https://api.github.com/repos/${this.repo}/issues`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${this.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                        'User-Agent': 'GitHub-Project-Board/1.0'
                    },
                    body: JSON.stringify({
                        title: item.title,
                        body: item.body,
                        labels: item.labels,
                        assignee: item.assignee || null
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to create issue: ${response.status}`);
                }

                const createdIssue = await response.json();
                
                const localItem = this.items.find(i => i.id === item.id);
                if (localItem) {
                    localItem.githubId = createdIssue.id;
                    localItem.githubNumber = createdIssue.number;
                    localItem.url = createdIssue.html_url;
                    localItem.synced = true;
                }

                this.log(`Created GitHub issue #${createdIssue.number}: ${item.title}`, 'success');
            }

            async updateGitHubIssue(item) {
                if (!item.githubNumber) {
                    throw new Error('Cannot update issue without GitHub number');
                }

                const response = await fetch(`https://api.github.com/repos/${this.repo}/issues/${item.githubNumber}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `token ${this.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json',
                        'User-Agent': 'GitHub-Project-Board/1.0'
                    },
                    body: JSON.stringify({
                        title: item.title,
                        body: item.body,
                        labels: item.labels,
                        assignee: item.assignee || null,
                        state: this.statusMapping[item.status] || 'open'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to update issue: ${response.status}`);
                }

                this.log(`Updated GitHub issue #${item.githubNumber}: ${item.title}`, 'success');
            }

            async closeGitHubIssue(item) {
                if (!item.githubNumber) {
                    this.log(`Cannot close GitHub issue - no issue number for: ${item.title}`, 'error');
                    return;
                }

                this.log(`📝 [SOURCE-003] Attempting to close GitHub issue #${item.githubNumber}: ${item.title}`, 'info');

                try {
                    // First close the issue
                    const response = await fetch(`https://api.github.com/repos/${this.repo}/issues/${item.githubNumber}`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json',
                            'User-Agent': 'GitHub-Project-Board/1.0'
                        },
                        body: JSON.stringify({
                            state: 'closed',
                            state_reason: 'completed'
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to close issue (${response.status}): ${errorText}`);
                    }

                    const result = await response.json();
                    this.log(`✅ [SOURCE-003] Successfully closed GitHub issue #${item.githubNumber}: ${item.title}`, 'success');
                    
                    // Add a comment indicating the item was deleted from the project board
                    const deletionComment = `🗑️ **Item deleted from project board** [SOURCE-003-DELETE]\n\nThis issue was removed from the project board and has been automatically closed.\n\n_Generated by GitHub Project Board_`;
                    await this.addCommentToIssue(item.githubNumber, deletionComment);
                    
                    this.log(`📝 [SOURCE-003] Added deletion comment to issue #${item.githubNumber}`, 'success');
                    
                    return result;
                } catch (error) {
                    this.log(`❌ [SOURCE-003] Failed to close GitHub issue #${item.githubNumber}: ${error.message}`, 'error');
                    throw error;
                }
            }

            async addCommentToIssue(issueNumber, commentBody) {
                try {
                    const response = await fetch(`https://api.github.com/repos/${this.repo}/issues/${issueNumber}/comments`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json',
                            'User-Agent': 'GitHub-Project-Board/1.0'
                        },
                        body: JSON.stringify({
                            body: commentBody
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to add comment (${response.status}): ${errorText}`);
                    }

                    const result = await response.json();
                    return result;
                } catch (error) {
                    this.log(`Failed to add comment to issue #${issueNumber}: ${error.message}`, 'error');
                    throw error;
                }
            }

            queueSyncOperation(type, item) {
                // For comment operations, check if we already have a similar one queued
                if (type === 'comment' && item.operationType === 'status_change') {
                    const existingSimilar = this.syncQueue.find(op => 
                        op.type === 'comment' && 
                        op.data.githubNumber === item.githubNumber &&
                        op.data.operationType === 'status_change' &&
                        Math.abs(op.timestamp - Date.now()) < 2000 // Within 2 seconds
                    );
                    
                    if (existingSimilar) {
                        this.log(`🚫 [SOURCE-004] Preventing duplicate comment operation for issue #${item.githubNumber}`, 'info');
                        return;
                    }
                }
                
                const operation = {
                    id: this.generateId(),
                    type,
                    data: { ...item },
                    timestamp: Date.now()
                };

                this.syncQueue.push(operation);
                localStorage.setItem('sync_queue', JSON.stringify(this.syncQueue));
                this.updateQueueDisplay();
                
                const operationNames = {
                    'create': 'create',
                    'update': 'update',
                    'close': 'delete',
                    'comment': 'status change comment'
                };
                
                const sourceInfo = item.sourceLocation ? ` [${item.sourceLocation}]` : '';
                this.log(`📝 [SOURCE-004] Queued ${operationNames[type] || type} operation for: ${item.title}${sourceInfo}`, 'info');
                
                if (this.isOnline) {
                    // Use a longer delay to prevent rapid-fire processing
                    clearTimeout(this.syncTimeout);
                    this.syncTimeout = setTimeout(() => this.processSyncQueue(), 1500);
                }
            }

            updateQueueDisplay() {
                const queueBtn = document.getElementById('queueBtn');
                const queueCount = document.getElementById('queueCount');
                
                if (this.syncQueue.length > 0) {
                    queueBtn.style.display = 'inline-block';
                    queueCount.textContent = this.syncQueue.length;
                } else {
                    queueBtn.style.display = 'none';
                }
            }

            showSyncQueue() {
                if (this.syncQueue.length === 0) {
                    alert('Sync queue is empty');
                    return;
                }

                const operationNames = {
                    'create': '➕ CREATE',
                    'update': '✏️ UPDATE', 
                    'close': '🗑️ DELETE',
                    'comment': '💬 COMMENT'
                };

                const queueInfo = this.syncQueue.map((op, index) => {
                    const opName = operationNames[op.type] || op.type.toUpperCase();
                    const timestamp = new Date(op.timestamp).toLocaleTimeString();
                    return `${index + 1}. ${opName}: ${op.data.title} (${timestamp})`;
                }).join('\n');

                const message = `Sync Queue (${this.syncQueue.length} operations):\n\n${queueInfo}\n\nProcess queue now?`;
                
                if (confirm(message)) {
                    this.processSyncQueue();
                }
            }

            downloadTemplate() {
                // Show format selection dialog
                const format = prompt(
                    'Choose template format:\n\n' +
                    '1. JSON (recommended)\n' +
                    '2. CSV (basic)\n\n' +
                    'Enter 1 or 2:', 
                    '1'
                );
                
                if (format === '1' || format === 'json' || format === 'JSON') {
                    this.downloadJSONTemplate();
                } else if (format === '2' || format === 'csv' || format === 'CSV') {
                    this.downloadCSVTemplate();
                } else if (format !== null) {
                    this.log('Invalid format selection. Use 1 for JSON or 2 for CSV.', 'error');
                }
            }

            downloadJSONTemplate() {
                const template = [
                    {
                        title: "Fix login authentication bug",
                        body: "Users are unable to login with their credentials. This affects the main authentication flow and needs immediate attention.\n\n## Steps to Reproduce\n1. Go to login page\n2. Enter valid credentials\n3. Click login button\n\n## Expected Result\nUser should be logged in successfully\n\n## Actual Result\nError message appears",
                        status: "todo",
                        labels: ["bug", "high-priority", "authentication"],
                        assignee: "developer-username"
                    },
                    {
                        title: "Add dark mode toggle",
                        body: "Implement a dark mode theme option in the user interface.\n\n- [ ] Design dark color scheme\n- [ ] Create toggle component\n- [ ] Save user preference\n- [ ] Test accessibility",
                        status: "backlog",
                        labels: ["feature", "ui/ux", "enhancement"],
                        assignee: ""
                    },
                    {
                        title: "Update API documentation",
                        body: "The API documentation needs to be updated to reflect the new endpoints added in v2.0",
                        status: "in-progress",
                        labels: ["documentation", "api"],
                        assignee: "tech-writer"
                    },
                    {
                        title: "Performance optimization research",
                        body: "Research and document potential performance improvements for the dashboard loading times.",
                        status: "review",
                        labels: ["performance", "research"],
                        assignee: "senior-dev"
                    },
                    {
                        title: "Setup automated testing pipeline",
                        body: "Configure CI/CD pipeline with automated testing for pull requests.",
                        status: "done",
                        labels: ["devops", "testing", "automation"],
                        assignee: "devops-engineer"
                    }
                ];

                const templateWithMeta = {
                    _template_info: {
                        version: "1.0",
                        description: "GitHub Project Board Bulk Import Template",
                        instructions: [
                            "Replace the example items below with your own data",
                            "All fields are optional except 'title'",
                            "Valid status values: backlog, todo, in-progress, review, done",
                            "Labels should be an array of strings",
                            "Assignee should be a GitHub username (optional)",
                            "Body supports Markdown formatting"
                        ],
                        required_fields: ["title"],
                        optional_fields: ["body", "status", "labels", "assignee"]
                    },
                    items: template
                };

                const blob = new Blob([JSON.stringify(templateWithMeta, null, 2)], {
                    type: 'application/json'
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `github-project-board-template-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.log('Downloaded JSON template with example data', 'success');
            }

            downloadCSVTemplate() {
                const csvTemplate = `title,body,status,labels,assignee
"Fix login authentication bug","Users are unable to login with their credentials. This affects the main authentication flow.","todo","bug,high-priority,authentication","developer-username"
"Add dark mode toggle","Implement a dark mode theme option in the user interface.","backlog","feature,ui/ux,enhancement",""
"Update API documentation","The API documentation needs to be updated to reflect the new endpoints added in v2.0","in-progress","documentation,api","tech-writer"
"Performance optimization research","Research and document potential performance improvements for the dashboard loading times.","review","performance,research","senior-dev"
"Setup automated testing pipeline","Configure CI/CD pipeline with automated testing for pull requests.","done","devops,testing,automation","devops-engineer"`;

                const blob = new Blob([csvTemplate], {
                    type: 'text/csv'
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `github-project-board-template-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.log('Downloaded CSV template with example data', 'success');
            }

            showItemModal(item = null) {
                const modal = document.getElementById('itemModal');
                const form = document.getElementById('itemForm');
                
                if (item) {
                    document.getElementById('itemTitle').value = item.title;
                    document.getElementById('itemBody').value = item.body;
                    document.getElementById('itemStatus').value = item.status;
                    document.getElementById('itemLabels').value = item.labels.join(', ');
                    document.getElementById('itemAssignee').value = item.assignee;
                    form.dataset.editId = item.id;
                } else {
                    form.reset();
                    delete form.dataset.editId;
                }
                
                modal.classList.add('show');
                document.getElementById('itemTitle').focus();
            }

            hideItemModal() {
                document.getElementById('itemModal').classList.remove('show');
            }

            handleItemSubmit(e) {
                e.preventDefault();
                
                const form = e.target;
                const editId = form.dataset.editId;
                
                const itemData = {
                    title: document.getElementById('itemTitle').value.trim(),
                    body: document.getElementById('itemBody').value.trim(),
                    status: document.getElementById('itemStatus').value,
                    labels: document.getElementById('itemLabels').value
                        .split(',')
                        .map(label => label.trim())
                        .filter(label => label),
                    assignee: document.getElementById('itemAssignee').value.trim()
                };

                if (!itemData.title) {
                    this.log('[SOURCE-006] Title is required', 'error');
                    return;
                }

                if (editId) {
                    this.log(`📝 [SOURCE-006] Form submit - updating item via modal`, 'info');
                    this.updateItem(editId, itemData);
                } else {
                    this.log(`📝 [SOURCE-006] Form submit - creating new item via modal`, 'info');
                    this.createItem(itemData);
                }

                this.hideItemModal();
            }

            createItem(data) {
                const item = {
                    id: this.generateId(),
                    ...data,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    synced: false
                };

                this.items.push(item);
                this.saveData();
                this.renderBoard();
                this.log(`Created item: ${item.title}`, 'success');

                if (this.token && this.repo) {
                    this.queueSyncOperation('create', item);
                }
            }

            addStatusChangeComment(item, oldStatus, newStatus, sourceLocation = 'unknown') {
                this.log(`🔍 [DEBUG] addStatusChangeComment called with sourceLocation: "${sourceLocation}"`, 'info');
                
                if (!this.token || !this.repo || !item.synced || !item.githubNumber) {
                    this.log(`🔍 [DEBUG] Skipping comment - missing requirements: token=${!!this.token}, repo=${!!this.repo}, synced=${!!item.synced}, githubNumber=${!!item.githubNumber}`, 'info');
                    return;
                }
                
                const statusMap = {
                    'backlog': 'Backlog',
                    'todo': 'To Do',
                    'in-progress': 'In Progress', 
                    'review': 'Review',
                    'done': 'Done'
                };
                
                const comment = `📋 **Status changed on project board** [SOURCE-${sourceLocation}]\n\n**${statusMap[oldStatus] || oldStatus}** → **${statusMap[newStatus] || newStatus}**\n\n_Generated by GitHub Project Board_`;
                
                this.log(`🔍 [DEBUG] Generated comment text: "${comment}"`, 'info');
                
                this.queueSyncOperation('comment', {
                    ...item,
                    commentBody: comment,
                    operationType: 'status_change',
                    sourceLocation: sourceLocation
                });
                
                this.log(`📝 [SOURCE-${sourceLocation}] Queued status change comment: ${oldStatus} → ${newStatus} for ${item.title}`, 'info');
            }

            updateItem(id, data) {
                const item = this.items.find(item => item.id === id);
                if (!item) return;

                const oldStatus = item.status;
                
                Object.assign(item, data, {
                    updatedAt: new Date().toISOString()
                });

                this.saveData();
                this.renderBoard();
                this.log(`📝 [SOURCE-001] Updated item: ${item.title}`, 'success');

                // Only add status change comment if status actually changed
                if (oldStatus !== item.status) {
                    this.addStatusChangeComment(item, oldStatus, item.status, '001-UPDATE-ITEM');
                }

                if (this.token && this.repo && item.synced) {
                    this.queueSyncOperation('update', item);
                }
            }

            deleteItem(id) {
                const item = this.items.find(item => item.id === id);
                if (!item) return;

                let confirmMessage = 'Are you sure you want to delete this item?';
                if (item.synced && item.githubNumber) {
                    confirmMessage = `Delete "${item.title}"?\n\nThis will:\n• Remove it from the board\n• Close GitHub issue #${item.githubNumber}\n• Add a comment indicating it was deleted from the project board\n\nNote: GitHub issues cannot be permanently deleted, only closed.`;
                }

                if (!confirm(confirmMessage)) return;

                const itemIndex = this.items.findIndex(item => item.id === id);
                if (itemIndex === -1) return;

                this.items.splice(itemIndex, 1);
                
                this.saveData();
                this.renderBoard();
                
                if (item.synced && item.githubNumber && this.token && this.repo) {
                    this.log(`Deleted item and queuing GitHub issue #${item.githubNumber} for closure with deletion comment: ${item.title}`, 'success');
                    // Queue for GitHub sync to close the issue and add comment
                    this.queueSyncOperation('close', item);
                    
                    // If online, process the close operation with the same timeout system
                    if (this.isOnline) {
                        clearTimeout(this.syncTimeout);
                        this.syncTimeout = setTimeout(() => {
                            this.log('Processing close operation immediately...', 'info');
                            this.processSyncQueue();
                        }, 1500);
                    }
                } else {
                    this.log(`Deleted local item: ${item.title}`, 'success');
                }
            }

            moveItem(itemId, newStatus) {
                const item = this.items.find(item => item.id === itemId);
                if (!item || item.status === newStatus) return;

                const oldStatus = item.status;
                item.status = newStatus;
                item.updatedAt = new Date().toISOString();

                this.saveData();
                this.renderBoard();
                this.log(`📝 [SOURCE-002] Moved item "${item.title}" from ${oldStatus} to ${newStatus}`, 'success');

                // Add status change comment - using centralized function
                this.addStatusChangeComment(item, oldStatus, newStatus, '002-MOVE-ITEM');

                if (this.token && this.repo && item.synced) {
                    this.queueSyncOperation('update', item);
                }
            }

            setupDragAndDrop() {
                let draggedItem = null;

                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('item')) {
                        draggedItem = e.target;
                        e.target.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', e.target.outerHTML);
                    }
                });

                document.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('item')) {
                        e.target.classList.remove('dragging');
                        draggedItem = null;
                    }
                });

                document.addEventListener('dragover', (e) => {
                    if (draggedItem) {
                        e.preventDefault();
                        const column = e.target.closest('.column');
                        if (column) {
                            column.classList.add('drag-over');
                        }
                    }
                });

                document.addEventListener('dragleave', (e) => {
                    const column = e.target.closest('.column');
                    if (column && !column.contains(e.relatedTarget)) {
                        column.classList.remove('drag-over');
                    }
                });

                document.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    const column = e.target.closest('.column');
                    if (column && draggedItem) {
                        column.classList.remove('drag-over');
                        
                        const newStatus = column.dataset.status;
                        const itemId = draggedItem.dataset.id;
                        
                        if (itemId && newStatus) {
                            this.moveItem(itemId, newStatus);
                        }
                    }
                });
            }

            renderBoard() {
                const columns = ['backlog', 'todo', 'in-progress', 'review', 'done'];
                
                columns.forEach(status => {
                    const container = document.getElementById(`${status}-items`);
                    const items = this.getFilteredItems().filter(item => item.status === status);
                    
                    container.innerHTML = '';
                    
                    items.forEach(item => {
                        const itemElement = this.createItemElement(item);
                        container.appendChild(itemElement);
                    });

                    document.getElementById(`${status}-count`).textContent = items.length;
                });
            }

            createItemElement(item) {
                const element = document.createElement('div');
                element.className = `item ${item.synced ? 'github-synced' : ''}`;
                element.draggable = true;
                element.dataset.id = item.id;

                const labelsHtml = item.labels.map(label => 
                    `<span class="label">${label}</span>`
                ).join('');

                element.innerHTML = `
                    <div class="item-header">
                        <div class="item-title">${this.escapeHtml(item.title)}</div>
                        ${item.githubNumber ? `<div class="item-number">#${item.githubNumber}</div>` : ''}
                    </div>
                    ${item.body ? `<div class="item-body">${this.truncateText(this.escapeHtml(item.body), 100)}</div>` : ''}
                    <div class="item-meta">
                        <div class="item-labels">${labelsHtml}</div>
                        <div class="item-assignee">${item.assignee ? '@' + item.assignee : ''}</div>
                    </div>
                `;

                element.addEventListener('dblclick', () => this.showItemModal(item));
                
                element.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (confirm('Delete this item?')) {
                        this.deleteItem(item.id);
                    }
                });

                return element;
            }

            searchItems(query) {
                this.searchQuery = query.toLowerCase();
                this.renderBoard();
            }

            filterItems(filter) {
                this.currentFilter = filter;
                this.renderBoard();
            }

            getFilteredItems() {
                let items = [...this.items];

                if (this.currentFilter === 'github') {
                    items = items.filter(item => item.synced);
                } else if (this.currentFilter === 'local') {
                    items = items.filter(item => !item.synced);
                }

                if (this.searchQuery) {
                    items = items.filter(item =>
                        item.title.toLowerCase().includes(this.searchQuery) ||
                        item.body.toLowerCase().includes(this.searchQuery) ||
                        item.labels.some(label => label.toLowerCase().includes(this.searchQuery))
                    );
                }

                return items.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            }

            bulkImport() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,.csv';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            let data;
                            if (file.name.endsWith('.json')) {
                                data = JSON.parse(e.target.result);
                            } else {
                                const lines = e.target.result.split('\n');
                                const headers = lines[0].split(',');
                                data = lines.slice(1).map(line => {
                                    const values = line.split(',');
                                    return headers.reduce((obj, header, index) => {
                                        obj[header.trim()] = values[index]?.trim() || '';
                                        return obj;
                                    }, {});
                                });
                            }

                            this.importItems(data);
                        } catch (error) {
                            this.log(`Import failed: ${error.message}`, 'error');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            }

            importItems(data) {
                if (!Array.isArray(data)) {
                    // Handle template format with items array
                    if (data.items && Array.isArray(data.items)) {
                        data = data.items;
                    } else {
                        this.log('Import data must be an array', 'error');
                        return;
                    }
                }

                let imported = 0;
                
                data.forEach(itemData => {
                    if (itemData.title) {
                        const item = {
                            id: this.generateId(),
                            title: itemData.title,
                            body: itemData.body || itemData.description || '',
                            status: itemData.status || 'backlog',
                            labels: Array.isArray(itemData.labels) ? itemData.labels : 
                                   (itemData.labels ? itemData.labels.split(',').map(l => l.trim()) : []),
                            assignee: itemData.assignee || '',
                            createdAt: new Date().toISOString(),
                            updatedAt: new Date().toISOString(),
                            synced: false
                        };

                        this.items.push(item);
                        imported++;
                    }
                });

                this.saveData();
                this.renderBoard();
                this.log(`Imported ${imported} items`, 'success');
            }

            exportData() {
                const data = {
                    items: this.items,
                    exported: new Date().toISOString(),
                    version: '1.0'
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], {
                    type: 'application/json'
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `project-board-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.log(`Exported ${this.items.length} items`, 'success');
            }

            loadInitialData() {
                if (this.token && this.repo) {
                    document.getElementById('tokenInput').value = this.token;
                    document.getElementById('repoInput').value = this.repo;
                    this.updateConnectionStatus(true);
                    document.getElementById('syncBtn').disabled = false;
                    
                    // Restore connection info if available
                    if (this.connectedUser) {
                        this.showConnectionBanner();
                    }
                }
            }

            startPeriodicSync() {
                setInterval(() => {
                    if (this.token && this.repo && this.isOnline) {
                        this.syncWithGitHub();
                    }
                }, 5 * 60 * 1000);
            }

            updateConnectionStatus(connected = false) {
                const indicator = document.getElementById('connectionStatus');
                
                if (connected === 'syncing') {
                    indicator.className = 'status-indicator syncing';
                } else if (connected) {
                    indicator.className = 'status-indicator connected';
                } else {
                    indicator.className = 'status-indicator disconnected';
                }
            }

            showOfflineIndicator() {
                document.getElementById('offlineIndicator').style.display = 'block';
            }

            hideOfflineIndicator() {
                document.getElementById('offlineIndicator').style.display = 'none';
            }

            toggleDebug() {
                this.debugMode = !this.debugMode;
                const panel = document.getElementById('debugPanel');
                
                if (this.debugMode) {
                    panel.classList.add('show');
                    this.log('Debug mode enabled', 'info');
                } else {
                    panel.classList.remove('show');
                }
            }

            saveData() {
                localStorage.setItem('board_items', JSON.stringify(this.items));
                this.log(`Saved ${this.items.length} items locally`);
            }

            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            truncateText(text, length) {
                return text.length > length ? text.substring(0, length) + '...' : text;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GitHubProjectBoard();
        });
    </script>
</body>
</html>